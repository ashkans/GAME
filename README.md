# unit_dev  

This package is a tool to automatically generate, and mark individualized questions for each student in a class. It consists of three parts: 1) making the questions, 2) a GUI for each question to assist students to make answer files (a formated excel file) suitable for marking, and 3) a marking routing. The structure of each part and the way that a designer should interact with them are explained below.
For the unit civ3204 as a pilot, 9 assignment with a different number of questions in each one is developed. 

## Making the questions:

## GUI:

## Marking:
Marking process is happening for each question in an assignment individually. Marking process consists of 5 parts:

* "input_reader" function which reads the input files. Input files contain the information that is provided to students, as a part of the question or supplementary data.
    
* "result_reader" function which reads the result files. These files are generated by each student based on the personalized input file and using the assisting GUI.
    
* "marker" function which receives an input file and a result file. It then regenerates the correct results and compares them with the results provided by students. The outputs of this function are a mark (float number) and a feedbacks (a list of string ). The marks will then automatically be written in a consolidated CSV file and the feedbacks will be automatically written to a formatted personalized tex file to be provided to the students.
    
* "get_paths" function. This function receives the "base_path,Student_id,questionID" and will produce the corresponding path to input_file, result_file and feedback_path.
    
* "main" function. This function is a wrapper for all other function and connects everything.
    
* There are some other functions and classes which are stored in other files that are doing complementary tasks.
    
To form a new assignment a new assignment runner should be generate (e.g. assignment1_runner.py). Each assignment should consist of one or more questions and should be specified as below:

        def get_question_list():
            return {{name}:Question({input_loader}, {result_loader}, {marker}, {get_paths}, {name}),
                    {name}:Question({input_loader}, {result_loader}, {marker}, {get_paths}, {name}),
                    ...
                    {name}:Question({input_loader}, {result_loader}, {marker}, {get_paths}, {name})
                   }

As you can see each questions need a name (string), an input_loader (function), a result loader (fucntion), a marker (fucntion), and a get_path (function). In the current structure, all of these function are stored under (./Assignments/assignment{x}/q{x}{y}, x is assignment number and y is the question number).

    
To install a new enviroment use:
conda env create -f environment.yml    

get all installed env on your conda:    
conda env list

save env:
conda env export > environment.yml


to update env:
source activate myenv
conda env update --file local.yml

conda env update --name myenv --file local.yml


to instal juypyterlabn in an enviroment:
conda install -c conda-forge jupyterlab
conda install -c conda-forge notebook


To install conda:
cd /tmp
curl -O https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh
sha256sum Anaconda3-2019.03-Linux-x86_64.sh
bash Anaconda3-2019.03-Linux-x86_64.sh